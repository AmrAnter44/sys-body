import { NextResponse } from 'next/server'
import { prisma } from '../../../../lib/prisma'
import { requireValidLicense } from '../../../../lib/license'
import { requirePermission } from '../../../../lib/auth'
import {
  type PaymentMethod,
  validatePaymentDistribution,
  serializePaymentMethods
} from '../../../../lib/paymentHelpers'
import { processPaymentWithPoints } from '../../../../lib/paymentProcessor'
import { RECEIPT_TYPES } from '../../../../lib/receiptTypes'

export const dynamic = 'force-dynamic'

export async function POST(request: Request) {
  try {
    // âœ… Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØµÙ„Ø§Ø­ÙŠØ© Ø¥Ù†Ø´Ø§Ø¡ PT (ØªØ´Ù…Ù„ Ø§Ù„ØªØ¬Ø¯ÙŠØ¯)
    await requirePermission(request, 'canCreatePT')

    const body = await request.json()
    const {
      ptNumber,
      phone,
      sessionsPurchased,
      coachName,
      totalPrice,
      startDate,
      expiryDate,
      paymentMethod,
      staffName
    } = body

    // Ø­Ø³Ø§Ø¨ Ø³Ø¹Ø± Ø§Ù„Ø­ØµØ© Ø§Ù„ÙˆØ§Ø­Ø¯Ø© Ù…Ù† Ø§Ù„Ø³Ø¹Ø± Ø§Ù„Ø¥Ø¬Ù…Ø§Ù„ÙŠ
    const pricePerSession = sessionsPurchased > 0 ? totalPrice / sessionsPurchased : 0

    console.log('ğŸ”„ ØªØ¬Ø¯ÙŠØ¯ Ø¬Ù„Ø³Ø§Øª PT:', { ptNumber, sessionsPurchased, totalPrice, pricePerSession })

    // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ÙˆØ¬ÙˆØ¯ Ø¬Ù„Ø³Ø© PT
    const existingPT = await prisma.pT.findUnique({
      where: { ptNumber: parseInt(ptNumber) }
    })
    
    if (!existingPT) {
      return NextResponse.json(
        { error: 'Ø¬Ù„Ø³Ø© PT ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯Ø©' }, 
        { status: 404 }
      )
    }

    // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„ØªÙˆØ§Ø±ÙŠØ®
    if (startDate && expiryDate) {
      const start = new Date(startDate)
      const end = new Date(expiryDate)
      
      if (end <= start) {
        return NextResponse.json(
          { error: 'ØªØ§Ø±ÙŠØ® Ø§Ù„Ø§Ù†ØªÙ‡Ø§Ø¡ ÙŠØ¬Ø¨ Ø£Ù† ÙŠÙƒÙˆÙ† Ø¨Ø¹Ø¯ ØªØ§Ø±ÙŠØ® Ø§Ù„Ø¨Ø¯Ø§ÙŠØ©' },
          { status: 400 }
        )
      }
    }

    // Ø­ÙØ¸ Ø§Ù„Ù…Ø¨Ù„Øº Ø§Ù„Ù…ØªØ¨Ù‚ÙŠ Ø§Ù„Ù‚Ø¯ÙŠÙ… Ù‚Ø¨Ù„ Ø§Ù„ØªØ­Ø¯ÙŠØ«
    const oldRemainingAmount = existingPT.remainingAmount || 0

    // ØªØ­Ø¯ÙŠØ« Ø¬Ù„Ø³Ø© PT (Ø§Ø³ØªØ¨Ø¯Ø§Ù„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø¨Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø© ÙˆØ¥Ø±Ø¬Ø§Ø¹ Ø§Ù„Ù…Ø¨Ù„Øº Ø§Ù„Ù…ØªØ¨Ù‚ÙŠ)
    const updatedPT = await prisma.pT.update({
      where: { ptNumber: parseInt(ptNumber) },
      data: {
        phone,
        sessionsPurchased: sessionsPurchased,
        sessionsRemaining: sessionsPurchased,
        coachName,
        pricePerSession,
        startDate: startDate ? new Date(startDate) : existingPT.startDate,
        expiryDate: expiryDate ? new Date(expiryDate) : existingPT.expiryDate,
        remainingAmount: 0, // âœ… ØªØµÙÙŠØ± Ø§Ù„Ù…Ø¨Ù„Øº Ø§Ù„Ù…ØªØ¨Ù‚ÙŠ Ø¹Ù†Ø¯ Ø§Ù„ØªØ¬Ø¯ÙŠØ¯
      },
    })

    console.log('âœ… ØªÙ… ØªØ­Ø¯ÙŠØ« Ø¬Ù„Ø³Ø© PT:', updatedPT.ptNumber)
    if (oldRemainingAmount > 0) {
      console.log(`ğŸ’° ØªÙ… Ø¥Ø±Ø¬Ø§Ø¹ Ø§Ù„Ù…Ø¨Ù„Øº Ø§Ù„Ù…ØªØ¨Ù‚ÙŠ: ${oldRemainingAmount} Ø¬.Ù…`)
    }

    // Ø¥Ù†Ø´Ø§Ø¡ Ø¥ÙŠØµØ§Ù„ Ù„Ù„ØªØ¬Ø¯ÙŠØ¯ Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Transaction
    try {
      // ğŸ”’ License validation check
      await requireValidLicense()

      // Ø§Ù„ØªØ£ÙƒØ¯ Ù…Ù† ÙˆØ¬ÙˆØ¯ totalPriceØŒ ÙˆØ¥Ù„Ø§ Ø§Ø­Ø³Ø¨Ù‡Ø§
      const totalAmount = totalPrice !== undefined && totalPrice !== null && totalPrice > 0
        ? Number(totalPrice)
        : Number(sessionsPurchased * pricePerSession)

      let subscriptionDays = null
      if (startDate && expiryDate) {
        const start = new Date(startDate)
        const end = new Date(expiryDate)
        subscriptionDays = Math.ceil((end.getTime() - start.getTime()) / (1000 * 60 * 60 * 24))
      }

      // Ø§Ø³ØªØ®Ø¯Ø§Ù… Transaction Ù…Ø¹ Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ø£ÙˆÙ„ Ø±Ù‚Ù… Ù…ØªØ§Ø­
      const result = await prisma.$transaction(async (tx) => {
        // Ø§Ø³ØªØ®Ø¯Ø§Ù… upsert Ù„ØªØ¬Ù†Ø¨ race condition
        const counter = await tx.receiptCounter.upsert({
          where: { id: 1 },
          update: { current: { increment: 1 } },
          create: { id: 1, current: 1001 },
        })

        const receiptNumber = counter.current
        console.log('ğŸ”¢ Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø±Ù‚Ù… Ø§Ù„Ø¥ÙŠØµØ§Ù„:', receiptNumber)

        // âœ… Ù…Ø¹Ø§Ù„Ø¬Ø© ÙˆØ³Ø§Ø¦Ù„ Ø§Ù„Ø¯ÙØ¹ Ø§Ù„Ù…ØªØ¹Ø¯Ø¯Ø©
        let finalPaymentMethod: string
        if (Array.isArray(paymentMethod)) {
          const validation = validatePaymentDistribution(paymentMethod, totalAmount)
          if (!validation.valid) {
            throw new Error(validation.message || 'ØªÙˆØ²ÙŠØ¹ Ø§Ù„Ù…Ø¨Ø§Ù„Øº ØºÙŠØ± ØµØ­ÙŠØ­')
          }
          finalPaymentMethod = serializePaymentMethods(paymentMethod)
        } else {
          finalPaymentMethod = paymentMethod || 'cash'
        }

        // Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø¥ÙŠØµØ§Ù„
        const receipt = await tx.receipt.create({
          data: {
            receiptNumber: receiptNumber,
            type: RECEIPT_TYPES.PT_RENEWAL,
            amount: totalAmount,
            paymentMethod: finalPaymentMethod,
            staffName: staffName || '',
            itemDetails: JSON.stringify({
              ptNumber: updatedPT.ptNumber,
              clientName: existingPT.clientName,
              phone: phone || existingPT.phone,
              sessionsPurchased: Number(sessionsPurchased),
              pricePerSession: Number(pricePerSession),
              totalAmount: totalAmount,
              coachName: coachName || existingPT.coachName,
              startDate: startDate || null,
              expiryDate: expiryDate || null,
              subscriptionDays: subscriptionDays,
              oldSessionsRemaining: existingPT.sessionsRemaining,
              newSessionsRemaining: updatedPT.sessionsRemaining,
              oldRemainingAmount: oldRemainingAmount, // âœ… Ø§Ù„Ù…Ø¨Ù„Øº Ø§Ù„Ù…ØªØ¨Ù‚ÙŠ Ø§Ù„Ù‚Ø¯ÙŠÙ… Ø§Ù„Ù…Ø±ØªØ¬Ø¹
              newRemainingAmount: 0, // âœ… Ø§Ù„Ù…Ø¨Ù„Øº Ø§Ù„Ù…ØªØ¨Ù‚ÙŠ Ø§Ù„Ø¬Ø¯ÙŠØ¯ (ØµÙØ±)
            }),
            ptNumber: updatedPT.ptNumber,
          },
        })

        // Ø®ØµÙ… Ø§Ù„Ù†Ù‚Ø§Ø· Ø¥Ø°Ø§ ØªÙ… Ø§Ø³ØªØ®Ø¯Ø§Ù…Ù‡Ø§ ÙÙŠ Ø§Ù„Ø¯ÙØ¹
        const pointsResult = await processPaymentWithPoints(
          null,  // Ù„Ø§ ÙŠÙˆØ¬Ø¯ memberId Ù„Ù€ PT
          phone || existingPT.phone,
          null,  // PT model doesn't have memberNumber field
          finalPaymentMethod,
          `Ø¯ÙØ¹ ØªØ¬Ø¯ÙŠØ¯ Ø¨Ø±Ø§ÙŠÙØª - ${existingPT.clientName}`,
          tx
        )

        if (!pointsResult.success) {
          throw new Error(pointsResult.message || 'ÙØ´Ù„ Ø®ØµÙ… Ø§Ù„Ù†Ù‚Ø§Ø·')
        }

        // âœ… Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† coachUserId Ù…Ù† Ø§Ù„ÙƒÙˆØªØ´
        let coachUserId = null
        if (coachName || existingPT.coachName) {
          const coachStaff = await tx.staff.findFirst({
            where: { name: coachName || existingPT.coachName },
            include: { user: true }
          })
          if (coachStaff?.user) {
            coachUserId = coachStaff.user.id
          }
        }

        // âœ… Ø¥Ù†Ø´Ø§Ø¡ Ø³Ø¬Ù„ Ø¹Ù…ÙˆÙ„Ø© Ù„Ù„ÙƒÙˆØªØ´
        if (coachUserId && totalAmount > 0) {
          try {
            const { createPTCommission } = await import('../../../../lib/commissionHelpers')
            await createPTCommission(
              tx,
              coachUserId,
              totalAmount,
              `Ø¹Ù…ÙˆÙ„Ø© ØªØ¬Ø¯ÙŠØ¯ Ø¨Ø±Ø§ÙŠÙØª - ${existingPT.clientName} (#${updatedPT.ptNumber})`,
              updatedPT.ptNumber
            )
          } catch (commissionError) {
            console.error('âš ï¸ ÙØ´Ù„ Ø¥Ù†Ø´Ø§Ø¡ Ø³Ø¬Ù„ Ø§Ù„Ø¹Ù…ÙˆÙ„Ø© (ØºÙŠØ± Ø­Ø±Ø¬):', commissionError)
          }
        }

        return receipt
      })

      console.log('âœ… ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ø¥ÙŠØµØ§Ù„ Ø§Ù„ØªØ¬Ø¯ÙŠØ¯ Ø¨Ù†Ø¬Ø§Ø­:', result.receiptNumber)

      return NextResponse.json({
        pt: updatedPT,
        receipt: {
          receiptNumber: result.receiptNumber,
          amount: result.amount,
          itemDetails: result.itemDetails,
          createdAt: result.createdAt
        }
      }, { status: 200 })

    } catch (receiptError: any) {
      console.error('âŒ Ø®Ø·Ø£ ÙÙŠ Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø¥ÙŠØµØ§Ù„:', receiptError)
      console.error('âŒ ØªÙØ§ØµÙŠÙ„ Ø§Ù„Ø®Ø·Ø£:', {
        message: receiptError.message,
        code: receiptError.code,
        meta: receiptError.meta,
        name: receiptError.name,
        stack: receiptError.stack
      })

      // Ø¥Ø±Ø¬Ø§Ø¹ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø­Ø¯Ø«Ø© Ø­ØªÙ‰ Ù„Ùˆ ÙØ´Ù„ Ø§Ù„Ø¥ÙŠØµØ§Ù„
      return NextResponse.json({
        pt: updatedPT,
        error: 'ØªÙ… Ø§Ù„ØªØ¬Ø¯ÙŠØ¯ Ø¨Ù†Ø¬Ø§Ø­ ÙˆÙ„ÙƒÙ† ÙØ´Ù„ Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø¥ÙŠØµØ§Ù„. ÙŠØ±Ø¬Ù‰ Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø¥ÙŠØµØ§Ù„ ÙŠØ¯ÙˆÙŠØ§Ù‹.',
        errorDetails: receiptError.message
      }, { status: 200 })
    }

  } catch (error) {
    console.error('âŒ Ø®Ø·Ø£ ÙÙŠ ØªØ¬Ø¯ÙŠØ¯ Ø¬Ù„Ø³Ø© PT:', error)
    return NextResponse.json({ error: 'ÙØ´Ù„ ØªØ¬Ø¯ÙŠØ¯ Ø¬Ù„Ø³Ø© PT' }, { status: 500 })
  }
}